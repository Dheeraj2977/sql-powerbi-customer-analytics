-- =============================================
-- Query 1: Total Revenue Generated
-- Description:
-- Calculates total platform revenue based on
-- quantity × price from order_items.
-- =============================================
SELECT 
ROUND(coalesce(SUM(PRICE*QUANTITY),0),2) AS TOTAL_REVENUE
FROM ORDER_ITEMS;

-- =============================================
-- Query 2: Monthly Revenue Trend
-- Description:
-- Calculates total revenue generated per month
-- and sorts results chronologically.
-- =============================================

SELECT 
DATE_FORMAT(O.ORDER_DATE,'%Y-%m') AS MONTH,
SUM(OI.PRICE*OI.QUANTITY) AS MONTHLY_REVENUE
FROM ORDERS O JOIN ORDER_ITEMS OI
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY MONTH
ORDER BY MONTH;

-- =============================================
-- Query 3: Top 10 Products by Revenue
-- Description:
-- Calculates total revenue per product and ranks
-- products based on revenue contribution using
-- window functions. Returns top 10 products.
-- =============================================

WITH PRODUCT_REVENUE AS(
SELECT P.PRODUCT_ID,P.PRODUCT_NAME,
SUM(OI.PRICE*OI.QUANTITY) AS TOTAL_REVENUE
FROM PRODUCTS P JOIN ORDER_ITEMS OI
ON P.PRODUCT_ID=OI.PRODUCT_ID
GROUP BY P.PRODUCT_ID,P.PRODUCT_NAME),
RANKED_PRODUCTS AS( select 
 PRODUCT_NAME,TOTAL_REVENUE,PRODUCT_ID,
RANK() OVER(ORDER BY TOTAL_REVENUE DESC) AS REVENUE_RANK
FROM PRODUCT_REVENUE)
SELECT 
    PRODUCT_NAME,PRODUCT_ID,
    TOTAL_REVENUE,
    REVENUE_RANK
FROM RANKED_PRODUCTS
WHERE REVENUE_RANK <= 10
ORDER BY REVENUE_RANK;

-- ============================================================
-- Query 4: Customer Lifetime Value (CLV) with Revenue Ranking
-- ------------------------------------------------------------
-- Business Objective:
-- Calculate total revenue generated by each customer
-- (Customer Lifetime Value) and rank customers based
-- on their contribution to total revenue.
--
-- Metrics Included:
-- - Total number of orders per customer
-- - Lifetime revenue (quantity × price)
-- - Revenue-based ranking using window functions
-- ============================================================

WITH CUSTOMER_REVENUE AS(
SELECT C.FIRST_NAME,C.CUSTOMER_ID,COUNT(DISTINCT O.ORDER_ID) AS TOTAL_ORDERS,
SUM(OI.PRICE*OI.QUANTITY) AS LIFETIME_VALUE
FROM CUSTOMERS C JOIN ORDERS O  
ON C.CUSTOMER_ID=O.CUSTOMER_ID
JOIN ORDER_ITEMS OI 
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY C.CUSTOMER_ID,C.FIRST_NAME)
SELECT FIRST_NAME,CUSTOMER_ID,TOTAL_ORDERS,LIFETIME_VALUE,
RANK() OVER(ORDER BY LIFETIME_VALUE DESC) AS REVENUE_RANK
FROM CUSTOMER_REVENUE
ORDER BY REVENUE_RANK;

-- ============================================================
-- Query 5: RFM Base Metrics Calculation
-- ------------------------------------------------------------
-- Business Objective:
-- Calculate Recency, Frequency, and Monetary (RFM)
-- metrics for each customer.
--
-- Recency  : Days since last purchase
-- Frequency: Total distinct orders
-- Monetary : Total revenue generated
-- ============================================================

WITH RFM_BASE AS(
SELECT
C.CUSTOMER_ID,C.FIRST_NAME,COUNT(DISTINCT O.ORDER_ID) AS FREQUENCY_ORDERS,
round(COALESCE(SUM(OI.PRICE*OI.QUANTITY),0),2) AS MONETARY_VALUES,
MAX(O.ORDER_DATE)AS LAST_ORDER_DATE,
DATEDIFF(CURRENT_DATE,MAX(O.ORDER_DATE)) AS RECENCY_DAYS
FROM CUSTOMERS C JOIN ORDERS O  
ON C.CUSTOMER_ID=O.CUSTOMER_ID
JOIN ORDER_ITEMS OI 
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY C.CUSTOMER_ID,C.FIRST_NAME)
SELECT * FROM RFM_BASE;

-- ============================================================
-- Query 6: RFM Scoring (1–5 Scale)
-- ------------------------------------------------------------
-- Business Objective:
-- Assign RFM scores using NTILE(5) window function.
-- ============================================================


WITH RFM_BASE AS(
SELECT
C.CUSTOMER_ID,C.FIRST_NAME,COUNT(DISTINCT O.ORDER_ID) AS FREQUENCY_ORDERS,
round(COALESCE(SUM(OI.PRICE*OI.QUANTITY),0),2) AS MONETARY_VALUES,
MAX(O.ORDER_DATE)AS LAST_ORDER_DATE,
DATEDIFF(CURRENT_DATE,MAX(O.ORDER_DATE)) AS RECENCY_DAYS
FROM CUSTOMERS C JOIN ORDERS O  
ON C.CUSTOMER_ID=O.CUSTOMER_ID
JOIN ORDER_ITEMS OI 
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY C.CUSTOMER_ID,C.FIRST_NAME),
rfm_scores AS (
    SELECT *,
           NTILE(5) OVER (ORDER BY  RECENCY_DAYS ASC ) AS recency_score,
           NTILE(5) OVER (ORDER BY FREQUENCY_ORDERS DESC ) AS frequency_score,
           NTILE(5) OVER (ORDER BY  MONETARY_VALUES DESC) AS monetary_score
    FROM rfm_base
)
SELECT * FROM 
rfm_scores;

-- ============================================================
-- Query 7: RFM Customer Segmentation
-- ------------------------------------------------------------
-- Business Objective:
-- Classify customers into behavioral segments
-- based on RFM scores.
-- ============================================================

WITH RFM_BASE AS(
SELECT
C.CUSTOMER_ID,C.FIRST_NAME,COUNT(DISTINCT O.ORDER_ID) AS FREQUENCY_ORDERS,
round(COALESCE(SUM(OI.PRICE*OI.QUANTITY),0),2) AS MONETARY_VALUES,
MAX(O.ORDER_DATE)AS LAST_ORDER_DATE,
DATEDIFF(CURRENT_DATE,MAX(O.ORDER_DATE)) AS RECENCY_DAYS
FROM CUSTOMERS C JOIN ORDERS O  
ON C.CUSTOMER_ID=O.CUSTOMER_ID
JOIN ORDER_ITEMS OI 
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY C.CUSTOMER_ID,C.FIRST_NAME),
rfm_scores AS (

    SELECT *,
    
           NTILE(5) OVER (ORDER BY  RECENCY_DAYS ASC ) AS recency_score,
           NTILE(5) OVER (ORDER BY FREQUENCY_ORDERS DESC ) AS frequency_score,
           NTILE(5) OVER (ORDER BY  MONETARY_VALUES DESC) AS monetary_score
    FROM rfm_base
)
SELECT *,
CONCAT(recency_score, frequency_score, monetary_score) AS rfm_score,
CASE
    WHEN recency_score >= 4 
         AND frequency_score >= 4 
         AND monetary_score >= 4
         THEN 'Champions'

    WHEN frequency_score >= 4 
         AND monetary_score >= 4
         THEN 'Loyal Customers'

    WHEN recency_score >= 4
         THEN 'Potential Loyalists'

    WHEN recency_score <= 2 
         AND frequency_score >= 3
         THEN 'At Risk'

    ELSE 'Lost Customers'
END AS customer_segment
 from rfm_scores;
 
 -- ============================================================
-- Query 8: Revenue Contribution by Customer Segment
-- ------------------------------------------------------------
-- Business Objective:
-- Analyze revenue distribution across RFM segments
-- to understand business impact of each group.
-- ============================================================

WITH RFM_BASE AS(
SELECT
C.CUSTOMER_ID,C.FIRST_NAME,COUNT(DISTINCT O.ORDER_ID) AS FREQUENCY_ORDERS,
round(COALESCE(SUM(OI.PRICE*OI.QUANTITY),0),2) AS MONETARY_VALUES,
MAX(O.ORDER_DATE)AS LAST_ORDER_DATE,
DATEDIFF(CURRENT_DATE,MAX(O.ORDER_DATE)) AS RECENCY_DAYS
FROM CUSTOMERS C JOIN ORDERS O  
ON C.CUSTOMER_ID=O.CUSTOMER_ID
JOIN ORDER_ITEMS OI 
ON O.ORDER_ID=OI.ORDER_ID
GROUP BY C.CUSTOMER_ID,C.FIRST_NAME),
rfm_scores AS (

    SELECT *,
    
           NTILE(5) OVER (ORDER BY  RECENCY_DAYS ASC ) AS recency_score,
           NTILE(5) OVER (ORDER BY FREQUENCY_ORDERS DESC ) AS frequency_score,
           NTILE(5) OVER (ORDER BY  MONETARY_VALUES DESC) AS monetary_score
    FROM rfm_base
),
rfm_segment as(
SELECT *,
CONCAT(recency_score, frequency_score, monetary_score) AS rfm_score,
CASE
    WHEN recency_score >= 4 
         AND frequency_score >= 4 
         AND monetary_score >= 4
         THEN 'Champions'

    WHEN frequency_score >= 4 
         AND monetary_score >= 4
         THEN 'Loyal Customers'

    WHEN recency_score >= 4
         THEN 'Potential Loyalists'

    WHEN recency_score <= 2 
         AND frequency_score >= 3
         THEN 'At Risk'

    ELSE 'Lost Customers'
END AS customer_segment
 from rfm_scores),
 segment_revenue AS (
    SELECT
        customer_segment,
        COUNT(customer_id) AS total_customers,
        SUM(monetary_values) AS segment_revenue
    FROM rfm_segment
    GROUP BY customer_segment
)

SELECT
    customer_segment,
    total_customers,
    segment_revenue,
    ROUND(
        (segment_revenue / SUM(segment_revenue) OVER ()) * 100,
        2
    ) AS revenue_percentage
FROM segment_revenue
ORDER BY segment_revenue DESC;
